{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _require = require('stream'),\n  Writable = _require.Writable;\nvar _require2 = require('../utils.js'),\n  getDecoder = _require2.getDecoder;\nvar URLEncoded = /*#__PURE__*/function (_Writable) {\n  _inherits(URLEncoded, _Writable);\n  function URLEncoded(cfg) {\n    var _this;\n    _classCallCheck(this, URLEncoded);\n    var streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined\n    };\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(URLEncoded).call(this, streamOpts));\n    var charset = cfg.defCharset || 'utf8';\n    if (cfg.conType.params && typeof cfg.conType.params.charset === 'string') charset = cfg.conType.params.charset;\n    _this.charset = charset;\n    var limits = cfg.limits;\n    _this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n    _this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n    _this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;\n    _this._inKey = true;\n    _this._keyTrunc = false;\n    _this._valTrunc = false;\n    _this._bytesKey = 0;\n    _this._bytesVal = 0;\n    _this._fields = 0;\n    _this._key = '';\n    _this._val = '';\n    _this._byte = -2;\n    _this._lastPos = 0;\n    _this._encode = 0;\n    _this._decoder = getDecoder(charset);\n    return _this;\n  }\n  _createClass(URLEncoded, [{\n    key: \"_write\",\n    value: function _write(chunk, enc, cb) {\n      if (this._fields >= this.fieldsLimit) return cb();\n      var i = 0;\n      var len = chunk.length;\n      this._lastPos = 0;\n\n      // Check if we last ended mid-percent-encoded byte\n      if (this._byte !== -2) {\n        i = readPctEnc(this, chunk, i, len);\n        if (i === -1) return cb(new Error('Malformed urlencoded form'));\n        if (i >= len) return cb();\n        if (this._inKey) ++this._bytesKey;else ++this._bytesVal;\n      }\n      main: while (i < len) {\n        if (this._inKey) {\n          // Parsing key\n\n          i = skipKeyBytes(this, chunk, i, len);\n          while (i < len) {\n            switch (chunk[i]) {\n              case 61:\n                // '='\n                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n                this._lastPos = ++i;\n                this._key = this._decoder(this._key, this._encode);\n                this._encode = 0;\n                this._inKey = false;\n                continue main;\n              case 38:\n                // '&'\n                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n                this._lastPos = ++i;\n                this._key = this._decoder(this._key, this._encode);\n                this._encode = 0;\n                if (this._bytesKey > 0) {\n                  this.emit('field', this._key, '', {\n                    nameTruncated: this._keyTrunc,\n                    valueTruncated: false,\n                    encoding: this.charset,\n                    mimeType: 'text/plain'\n                  });\n                }\n                this._key = '';\n                this._val = '';\n                this._keyTrunc = false;\n                this._valTrunc = false;\n                this._bytesKey = 0;\n                this._bytesVal = 0;\n                if (++this._fields >= this.fieldsLimit) {\n                  this.emit('fieldsLimit');\n                  return cb();\n                }\n                continue;\n              case 43:\n                // '+'\n                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n                this._key += ' ';\n                this._lastPos = i + 1;\n                break;\n              case 37:\n                // '%'\n                if (this._encode === 0) this._encode = 1;\n                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n                this._lastPos = i + 1;\n                this._byte = -1;\n                i = readPctEnc(this, chunk, i + 1, len);\n                if (i === -1) return cb(new Error('Malformed urlencoded form'));\n                if (i >= len) return cb();\n                ++this._bytesKey;\n                i = skipKeyBytes(this, chunk, i, len);\n                continue;\n            }\n            ++i;\n            ++this._bytesKey;\n            i = skipKeyBytes(this, chunk, i, len);\n          }\n          if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n        } else {\n          // Parsing value\n\n          i = skipValBytes(this, chunk, i, len);\n          while (i < len) {\n            switch (chunk[i]) {\n              case 38:\n                // '&'\n                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n                this._lastPos = ++i;\n                this._inKey = true;\n                this._val = this._decoder(this._val, this._encode);\n                this._encode = 0;\n                if (this._bytesKey > 0 || this._bytesVal > 0) {\n                  this.emit('field', this._key, this._val, {\n                    nameTruncated: this._keyTrunc,\n                    valueTruncated: this._valTrunc,\n                    encoding: this.charset,\n                    mimeType: 'text/plain'\n                  });\n                }\n                this._key = '';\n                this._val = '';\n                this._keyTrunc = false;\n                this._valTrunc = false;\n                this._bytesKey = 0;\n                this._bytesVal = 0;\n                if (++this._fields >= this.fieldsLimit) {\n                  this.emit('fieldsLimit');\n                  return cb();\n                }\n                continue main;\n              case 43:\n                // '+'\n                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n                this._val += ' ';\n                this._lastPos = i + 1;\n                break;\n              case 37:\n                // '%'\n                if (this._encode === 0) this._encode = 1;\n                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n                this._lastPos = i + 1;\n                this._byte = -1;\n                i = readPctEnc(this, chunk, i + 1, len);\n                if (i === -1) return cb(new Error('Malformed urlencoded form'));\n                if (i >= len) return cb();\n                ++this._bytesVal;\n                i = skipValBytes(this, chunk, i, len);\n                continue;\n            }\n            ++i;\n            ++this._bytesVal;\n            i = skipValBytes(this, chunk, i, len);\n          }\n          if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n        }\n      }\n      cb();\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      if (this._byte !== -2) return cb(new Error('Malformed urlencoded form'));\n      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {\n        if (this._inKey) this._key = this._decoder(this._key, this._encode);else this._val = this._decoder(this._val, this._encode);\n        this.emit('field', this._key, this._val, {\n          nameTruncated: this._keyTrunc,\n          valueTruncated: this._valTrunc,\n          encoding: this.charset,\n          mimeType: 'text/plain'\n        });\n      }\n      cb();\n    }\n  }], [{\n    key: \"detect\",\n    value: function detect(conType) {\n      return conType.type === 'application' && conType.subtype === 'x-www-form-urlencoded';\n    }\n  }]);\n  return URLEncoded;\n}(Writable);\nfunction readPctEnc(self, chunk, pos, len) {\n  if (pos >= len) return len;\n  if (self._byte === -1) {\n    // We saw a '%' but no hex characters yet\n    var hexUpper = HEX_VALUES[chunk[pos++]];\n    if (hexUpper === -1) return -1;\n    if (hexUpper >= 8) self._encode = 2; // Indicate high bits detected\n\n    if (pos < len) {\n      // Both hex characters are in this chunk\n      var hexLower = HEX_VALUES[chunk[pos++]];\n      if (hexLower === -1) return -1;\n      if (self._inKey) self._key += String.fromCharCode((hexUpper << 4) + hexLower);else self._val += String.fromCharCode((hexUpper << 4) + hexLower);\n      self._byte = -2;\n      self._lastPos = pos;\n    } else {\n      // Only one hex character was available in this chunk\n      self._byte = hexUpper;\n    }\n  } else {\n    // We saw only one hex character so far\n    var _hexLower = HEX_VALUES[chunk[pos++]];\n    if (_hexLower === -1) return -1;\n    if (self._inKey) self._key += String.fromCharCode((self._byte << 4) + _hexLower);else self._val += String.fromCharCode((self._byte << 4) + _hexLower);\n    self._byte = -2;\n    self._lastPos = pos;\n  }\n  return pos;\n}\nfunction skipKeyBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesKey > self.fieldNameSizeLimit) {\n    if (!self._keyTrunc) {\n      if (self._lastPos < pos) self._key += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._keyTrunc = true;\n    for (; pos < len; ++pos) {\n      var code = chunk[pos];\n      if (code === 61 /* '=' */ || code === 38 /* '&' */) break;\n      ++self._bytesKey;\n    }\n    self._lastPos = pos;\n  }\n  return pos;\n}\nfunction skipValBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesVal > self.fieldSizeLimit) {\n    if (!self._valTrunc) {\n      if (self._lastPos < pos) self._val += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._valTrunc = true;\n    for (; pos < len; ++pos) {\n      if (chunk[pos] === 38 /* '&' */) break;\n      ++self._bytesVal;\n    }\n    self._lastPos = pos;\n  }\n  return pos;\n}\n\n/* eslint-disable no-multi-spaces */\nvar HEX_VALUES = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = URLEncoded;","map":null,"metadata":{},"sourceType":"script"}
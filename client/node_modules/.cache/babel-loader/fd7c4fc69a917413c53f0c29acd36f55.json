{"ast":null,"code":"'use strict';\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\HarshGupta\\\\Desktop\\\\Tvs-Credit-It-Challenge\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _require = require('stream'),\n  Readable = _require.Readable,\n  Writable = _require.Writable;\nvar StreamSearch = require('streamsearch');\nvar _require2 = require('../utils.js'),\n  basename = _require2.basename,\n  convertToUTF8 = _require2.convertToUTF8,\n  getDecoder = _require2.getDecoder,\n  parseContentType = _require2.parseContentType,\n  parseDisposition = _require2.parseDisposition;\nvar BUF_CRLF = Buffer.from('\\r\\n');\nvar BUF_CR = Buffer.from('\\r');\nvar BUF_DASH = Buffer.from('-');\nfunction noop() {}\nvar MAX_HEADER_PAIRS = 2000; // From node\nvar MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nvar HPARSER_NAME = 0;\nvar HPARSER_PRE_OWS = 1;\nvar HPARSER_VALUE = 2;\nvar HeaderParser = /*#__PURE__*/function () {\n  function HeaderParser(cb) {\n    _classCallCheck(this, HeaderParser);\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n  _createClass(HeaderParser, [{\n    key: \"reset\",\n    value: function reset() {\n      this.header = Object.create(null);\n      this.pairCount = 0;\n      this.byteCount = 0;\n      this.state = HPARSER_NAME;\n      this.name = '';\n      this.value = '';\n      this.crlf = 0;\n    }\n  }, {\n    key: \"push\",\n    value: function push(chunk, pos, end) {\n      var start = pos;\n      while (pos < end) {\n        switch (this.state) {\n          case HPARSER_NAME:\n            {\n              var done = false;\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                var code = chunk[pos];\n                if (TOKEN[code] !== 1) {\n                  if (code !== 58 /* ':' */) return -1;\n                  this.name += chunk.latin1Slice(start, pos);\n                  if (this.name.length === 0) return -1;\n                  ++pos;\n                  done = true;\n                  this.state = HPARSER_PRE_OWS;\n                  break;\n                }\n              }\n              if (!done) {\n                this.name += chunk.latin1Slice(start, pos);\n                break;\n              }\n              // FALLTHROUGH\n            }\n\n          case HPARSER_PRE_OWS:\n            {\n              // Skip optional whitespace\n              var _done = false;\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                var _code = chunk[pos];\n                if (_code !== 32 /* ' ' */ && _code !== 9 /* '\\t' */) {\n                  start = pos;\n                  _done = true;\n                  this.state = HPARSER_VALUE;\n                  break;\n                }\n              }\n              if (!_done) break;\n              // FALLTHROUGH\n            }\n\n          case HPARSER_VALUE:\n            switch (this.crlf) {\n              case 0:\n                // Nothing yet\n                for (; pos < end; ++pos) {\n                  if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                  ++this.byteCount;\n                  var _code2 = chunk[pos];\n                  if (FIELD_VCHAR[_code2] !== 1) {\n                    if (_code2 !== 13 /* '\\r' */) return -1;\n                    ++this.crlf;\n                    break;\n                  }\n                }\n                this.value += chunk.latin1Slice(start, pos++);\n                break;\n              case 1:\n                // Received CR\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                if (chunk[pos++] !== 10 /* '\\n' */) return -1;\n                ++this.crlf;\n                break;\n              case 2:\n                {\n                  // Received CR LF\n                  if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                  ++this.byteCount;\n                  var _code3 = chunk[pos];\n                  if (_code3 === 32 /* ' ' */ || _code3 === 9 /* '\\t' */) {\n                    // Folded value\n                    start = pos;\n                    this.crlf = 0;\n                  } else {\n                    if (++this.pairCount < MAX_HEADER_PAIRS) {\n                      this.name = this.name.toLowerCase();\n                      if (this.header[this.name] === undefined) this.header[this.name] = [this.value];else this.header[this.name].push(this.value);\n                    }\n                    if (_code3 === 13 /* '\\r' */) {\n                      ++this.crlf;\n                      ++pos;\n                    } else {\n                      // Assume start of next header field name\n                      start = pos;\n                      this.crlf = 0;\n                      this.state = HPARSER_NAME;\n                      this.name = '';\n                      this.value = '';\n                    }\n                  }\n                  break;\n                }\n              case 3:\n                {\n                  // Received CR LF CR\n                  if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                  ++this.byteCount;\n                  if (chunk[pos++] !== 10 /* '\\n' */) return -1;\n                  // End of header\n                  var header = this.header;\n                  this.reset();\n                  this.cb(header);\n                  return pos;\n                }\n            }\n            break;\n        }\n      }\n      return pos;\n    }\n  }]);\n  return HeaderParser;\n}();\nvar FileStream = /*#__PURE__*/function (_Readable) {\n  _inherits(FileStream, _Readable);\n  function FileStream(opts, owner) {\n    var _this;\n    _classCallCheck(this, FileStream);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FileStream).call(this, opts));\n    _this.truncated = false;\n    _this._readcb = null;\n    _this.once('end', function () {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      _this._read();\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        var cb = owner._finalcb;\n        owner._finalcb = null;\n        // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n        process.nextTick(cb);\n      }\n    });\n    return _this;\n  }\n  _createClass(FileStream, [{\n    key: \"_read\",\n    value: function _read(n) {\n      var cb = this._readcb;\n      if (cb) {\n        this._readcb = null;\n        cb();\n      }\n    }\n  }]);\n  return FileStream;\n}(Readable);\nvar ignoreData = {\n  push: function push(chunk, pos) {},\n  destroy: function destroy() {}\n};\nfunction callAndUnsetCb(self, err) {\n  var cb = self._writecb;\n  self._writecb = null;\n  if (err) self.destroy(err);else if (cb) cb();\n}\nfunction nullDecoder(val, hint) {\n  return val;\n}\nvar Multipart = /*#__PURE__*/function (_Writable) {\n  _inherits(Multipart, _Writable);\n  function Multipart(cfg) {\n    var _this2;\n    _classCallCheck(this, Multipart);\n    var streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined\n    };\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Multipart).call(this, streamOpts));\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');\n    var boundary = cfg.conType.params.boundary;\n    var paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;\n    var defCharset = cfg.defCharset || 'utf8';\n    var preservePath = cfg.preservePath;\n    var fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined\n    };\n    var limits = cfg.limits;\n    var fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n    var fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;\n    var filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;\n    var fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n    var partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;\n    var parts = -1; // Account for initial boundary\n    var fields = 0;\n    var files = 0;\n    var skipPart = false;\n    _this2._fileEndsLeft = 0;\n    _this2._fileStream = undefined;\n    _this2._complete = false;\n    var fileSize = 0;\n    var field;\n    var fieldSize = 0;\n    var partCharset;\n    var partEncoding;\n    var partType;\n    var partName;\n    var partTruncated = false;\n    var hitFilesLimit = false;\n    var hitFieldsLimit = false;\n    _this2._hparser = null;\n    var hparser = new HeaderParser(function (header) {\n      _this2._hparser = null;\n      skipPart = false;\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n      var filename;\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n      var disp = parseDisposition(header['content-disposition'][0], paramDecoder);\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n      if (disp.params) {\n        if (disp.params.name) partName = disp.params.name;\n        if (disp.params['filename*']) filename = disp.params['filename*'];else if (disp.params.filename) filename = disp.params.filename;\n        if (filename !== undefined && !preservePath) filename = basename(filename);\n      }\n      if (header['content-type']) {\n        var conType = parseContentType(header['content-type'][0]);\n        if (conType) {\n          partType = \"\".concat(conType.type, \"/\").concat(conType.subtype);\n          if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n      if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            _this2.emit('filesLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++files;\n        if (_this2.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n        fileSize = 0;\n        _this2._fileStream = new FileStream(fileOpts, _assertThisInitialized(_assertThisInitialized(_this2)));\n        ++_this2._fileEndsLeft;\n        _this2.emit('file', partName, _this2._fileStream, {\n          filename: filename,\n          encoding: partEncoding,\n          mimeType: partType\n        });\n      } else {\n        // Non-file\n\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            _this2.emit('fieldsLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++fields;\n        if (_this2.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n        field = [];\n        fieldSize = 0;\n      }\n    });\n    var matchPostBoundary = 0;\n    var ssCb = function ssCb(isMatch, data, start, end, isDataSafe) {\n      retrydata: while (data) {\n        if (_this2._hparser !== null) {\n          var ret = _this2._hparser.push(data, start, end);\n          if (ret === -1) {\n            _this2._hparser = null;\n            hparser.reset();\n            _this2.emit('error', new Error('Malformed part header'));\n            break;\n          }\n          start = ret;\n        }\n        if (start === end) break;\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45:\n                // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n              case 13:\n                // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n              default:\n                matchPostBoundary = 0;\n            }\n            if (start === end) return;\n          }\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n            if (data[start] === 45 /* '-' */) {\n              // End of multipart data\n              _this2._complete = true;\n              _this2._bparser = ignoreData;\n              return;\n            }\n            // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n            var writecb = _this2._writecb;\n            _this2._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            _this2._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n            if (data[start] === 10 /* '\\n' */) {\n              ++start;\n              if (parts >= partsLimit) break;\n              // Prepare the header parser\n              _this2._hparser = hparser;\n              if (start === end) break;\n              // Process the remaining data as a header\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              var _writecb = _this2._writecb;\n              _this2._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              _this2._writecb = _writecb;\n            }\n          }\n        }\n        if (!skipPart) {\n          if (_this2._fileStream) {\n            var chunk = void 0;\n            var actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n            fileSize += chunk.length;\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0) _this2._fileStream.push(chunk);\n              _this2._fileStream.emit('limit');\n              _this2._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!_this2._fileStream.push(chunk)) {\n              if (_this2._writecb) _this2._fileStream._readcb = _this2._writecb;\n              _this2._writecb = null;\n            }\n          } else if (field !== undefined) {\n            var _chunk = void 0;\n            var _actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);\n            if (!isDataSafe) {\n              _chunk = Buffer.allocUnsafe(_actualLen);\n              data.copy(_chunk, 0, start, start + _actualLen);\n            } else {\n              _chunk = data.slice(start, start + _actualLen);\n            }\n            fieldSize += _actualLen;\n            field.push(_chunk);\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n        break;\n      }\n      if (isMatch) {\n        matchPostBoundary = 1;\n        if (_this2._fileStream) {\n          // End the active file stream if the previous part was a file\n          _this2._fileStream.push(null);\n          _this2._fileStream = null;\n        } else if (field !== undefined) {\n          var _data;\n          switch (field.length) {\n            case 0:\n              _data = '';\n              break;\n            case 1:\n              _data = convertToUTF8(field[0], partCharset, 0);\n              break;\n            default:\n              _data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);\n          }\n          field = undefined;\n          fieldSize = 0;\n          _this2.emit('field', partName, _data, {\n            nameTruncated: false,\n            valueTruncated: partTruncated,\n            encoding: partEncoding,\n            mimeType: partType\n          });\n        }\n        if (++parts === partsLimit) _this2.emit('partsLimit');\n      }\n    };\n    _this2._bparser = new StreamSearch(\"\\r\\n--\".concat(boundary), ssCb);\n    _this2._writecb = null;\n    _this2._finalcb = null;\n\n    // Just in case there is no preamble\n    _this2.write(BUF_CRLF);\n    return _this2;\n  }\n  _createClass(Multipart, [{\n    key: \"_write\",\n    value: function _write(chunk, enc, cb) {\n      this._writecb = cb;\n      this._bparser.push(chunk, 0);\n      if (this._writecb) callAndUnsetCb(this);\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, cb) {\n      this._hparser = null;\n      this._bparser = ignoreData;\n      if (!err) err = checkEndState(this);\n      var fileStream = this._fileStream;\n      if (fileStream) {\n        this._fileStream = null;\n        fileStream.destroy(err);\n      }\n      cb(err);\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      this._bparser.destroy();\n      if (!this._complete) return cb(new Error('Unexpected end of form'));\n      if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);else finalcb(this, cb);\n    }\n  }], [{\n    key: \"detect\",\n    value: function detect(conType) {\n      return conType.type === 'multipart' && conType.subtype === 'form-data';\n    }\n  }]);\n  return Multipart;\n}(Writable);\nfunction finalcb(self, cb, err) {\n  if (err) return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\nfunction checkEndState(self) {\n  if (self._hparser) return new Error('Malformed part header');\n  var fileStream = self._fileStream;\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n  if (!self._complete) return new Error('Unexpected end of form');\n}\nvar TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nvar FIELD_VCHAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nmodule.exports = Multipart;","map":null,"metadata":{},"sourceType":"script"}